<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Hex Book, all in one place.">
    <meta name="author" content="petrak@, Alwinfy">
    <link rel="icon" href="icon.png">

    <title>Hex Book</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css"
          integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">
    <style>
        summary { display: list-item; }

        details.spell-collapsible {
            display: inline-block;
            border: 1px solid #aaa;
            border-radius: 4px;
            padding: .5em .5em 0;
            margin-bottom: .5em;
        }

        summary.collapse-spell {
            font-weight: bold;
            margin: -.5em -.5em 0;
            padding: .5em;
        }

        details.spell-collapsible[open] {
            padding: .5em;
        }

        details[open] summary.collapse-spell {
            border-bottom: 1px solid #aaa;
            margin-bottom: .5em;
        }

        details .collapse-spell::before {
            content: "Click to show spell";
        }
        details[open] .collapse-spell::before {
            content: "Click to hide spell";
        }
        blockquote.crafting-info {
            font-size: inherit;
        }
        a.toggle-link {
            margin-left: 0.5em;
        }
        a.permalink {
            margin-left: 0.5em;
        }
        a.permalink:hover {
            color: lightgray;
        }
        p {
            margin: 0.5ex 0;
        }
        p.fake-li {
            margin: 0;
        }
        p.fake-li::before {
            content: "\2022";
            margin: 1ex;
        }
        .linkout::before {
            content: "Link: ";
        }
        p.todo-note {
            font-style: italic;
            color: lightgray;
        }
        .obfuscated {
            filter: blur(1em);
        }
        .spoilered {
            filter: blur(1ex);
            -moz-transition: filter 0.04s linear;
        }
        .spoilered:hover {
            filter: blur(0.5ex);
        }
        .spoilered.unspoilered {
            filter: blur(0);
        }
        canvas.spell-viz {
            --dot-color: #777f;
            --start-dot-color: #f009;
            --moving-dot-color: #0fa9;

            --path-color: darkgray;
            --visited-path-color: #0c8;

            --dot-scale: 0.0625;
            --moving-dot-scale: 0.125;
            --line-scale: 0.08333;
            --pausetext-scale: 0.5;
        }

    </style>
    <noscript>
        <style>
            /* for accessibility */
            .spoilered {
                filter: none !important;
            }

        </style>
    </noscript>
    <script>
        "use strict";
        const speeds = [0, 0.25, 0.5, 1, 2, 4];
        const scrollThreshold = 100;
        const rfaQueue = [];
        function startAngle(str) {
            switch (str) {
                case "east": return 0;
                case "north_east": return 1;
                case "north_west": return 2;
                case "west": return 3;
                case "south_west": return 4;
                case "south_east": return 5;
                default: return 0;
            }
        }
        function offsetAngle(str) {
            switch (str) {
                case "w": return 0;
                case "q": return 1;
                case "a": return 2;
                case "s": return 3;
                case "d": return 4;
                case "e": return 5;
                default: return -1;
            }
        }
        function initializeElem(canvas) {
            const str = canvas.dataset.string;
            let angle = startAngle(canvas.dataset.start);
            const perWorld = canvas.dataset.perWorld === "True";

            // build geometry
            const points = [[0, 0]];
            let lastPoint = points[0];
            let minPoint = lastPoint, maxPoint = lastPoint;
            for (const ch of "w" + str) {
                const addAngle = offsetAngle(ch);
                if (addAngle < 0) continue;
                angle = (angle + addAngle) % 6;
                const trueAngle = Math.PI / 3 * angle;

                const [lx, ly] = lastPoint;
                const newPoint = [lx + Math.cos(trueAngle), ly - Math.sin(trueAngle)];

                points.push(newPoint);
                lastPoint = newPoint;

                const [mix, miy] = minPoint;
                minPoint = [Math.min(mix, newPoint[0]), Math.min(miy, newPoint[1])];
                const [max, may] = maxPoint;
                maxPoint = [Math.max(max, newPoint[0]), Math.max(may, newPoint[1])];
            }
            const size = Math.min(canvas.width, canvas.height) * 0.8;
            const scale = size / Math.max(3, Math.max(maxPoint[1] - minPoint[1], maxPoint[0] - minPoint[0]));
            const center = [(minPoint[0] + maxPoint[0]) * 0.5, (minPoint[1] + maxPoint[1]) * 0.5];
            const truePoints = points.map(p => [canvas.width * 0.5 + scale * (p[0] - center[0]), canvas.height * 0.5 + scale * (p[1] - center[1])]);
            let uniqPoints = [];
            l1: for (const point of truePoints) {
                for (const pt of uniqPoints) {
                    if (Math.abs(point[0] - pt[0]) < 0.00001 && Math.abs(point[1] - pt[1]) < 0.00001) {
                        continue l1;
                    }
                }
                uniqPoints.push(point);
            }

            // rendering code
            const speed = 0.0025;
            const context = canvas.getContext("2d");
            const negaProgress = -3;
            let progress = 0;
            let scrollTimeout = 1e309;
            let speedLevel = 3;
            let speedIncrement = 0;
            function speedScale() {
                return speeds[speedLevel];
            }

            const style = getComputedStyle(canvas);
            const getProp = n => style.getPropertyValue(n);

            const tick = dt => {
                scrollTimeout += dt;
                if (canvas.offsetParent === null) return;

                const strokeStyle = getProp("--path-color");
                const strokeVisitedStyle = getProp("--visited-path-color");

                const startDotStyle = getProp("--start-dot-color");
                const dotStyle = getProp("--dot-color");
                const movDotStyle = getProp("--moving-dot-color");

                const strokeWidth = scale * +getProp("--line-scale");
                const dotRadius = scale * +getProp("--dot-scale");
                const movDotRadius = scale * +getProp("--moving-dot-scale");
                const pauseScale = scale * +getProp("--pausetext-scale");


                if (!perWorld) {
                    progress += speed * dt * (progress > 0 ? speedScale() : Math.sqrt(speedScale()));
                }
                if (progress >= truePoints.length - 1) {
                    progress = negaProgress;
                }
                let ix = Math.floor(progress), frac = progress - ix, core = null, fadeColor = 0;
                if (ix < 0) {
                    const rawFade = 2 * progress / negaProgress - 1;
                    fadeColor = 1 - Math.abs(rawFade);
                    context.strokeStyle = rawFade > 0 ? strokeVisitedStyle : strokeStyle;
                    ix = rawFade > 0 ? truePoints.length - 2 : 0;
                    frac = +(rawFade > 0);
                } else {
                    context.strokeStyle = strokeVisitedStyle;
                }

                const [lx, ly] = truePoints[ix];
                const [rx, ry] = truePoints[ix + 1];
                core = [lx + (rx - lx) * frac, ly + (ry - ly) * frac];


                context.clearRect(0, 0, canvas.width, canvas.height);
                context.beginPath();
                context.lineWidth = strokeWidth;
                context.moveTo(truePoints[0][0], truePoints[0][1]);
                for (let i = 1; i < ix + 1; i++) {
                    context.lineTo(truePoints[i][0], truePoints[i][1]);
                }
                context.lineTo(core[0], core[1]);
                context.stroke();
                context.beginPath();
                context.strokeStyle = strokeStyle;
                context.moveTo(core[0], core[1]);
                for (let i = ix + 1; i < truePoints.length; i++) {
                    context.lineTo(truePoints[i][0], truePoints[i][1]);
                }
                context.stroke();

                for (let i = 0; i < uniqPoints.length; i++) {
                    context.beginPath();
                    context.fillStyle = (i == 0 && !perWorld) ? startDotStyle : dotStyle;
                    const radius = (i == 0 && !perWorld) ? movDotRadius : dotRadius;
                    context.arc(uniqPoints[i][0], uniqPoints[i][1], radius, 0, 2 * Math.PI);
                    context.fill();
                }

                if (!perWorld) {
                    context.beginPath();
                    context.fillStyle = movDotStyle;
                    context.arc(core[0], core[1], movDotRadius, 0, 2 * Math.PI);
                    context.fill();
                }
                if (fadeColor) {
                    context.fillStyle = `rgba(255, 255, 255, ${fadeColor})`;
                    context.fillRect(0, 0, canvas.width, canvas.height);
                }
                if (scrollTimeout <= 2000) {
                    context.fillStyle = `rgba(200, 200, 200, ${(2000 - scrollTimeout) / 1000})`;
                    context.font = `${pauseScale}px sans-serif`;
                    context.fillText(speedScale() ? speedScale() + "x" : "Paused", 0.2 * scale, canvas.height - 0.2 * scale);
                }
            };
            rfaQueue.push(tick);

            // scrolling input
            if (!perWorld) {
                canvas.addEventListener("wheel", ev => {
                    speedIncrement += ev.deltaY;
                    const oldSpeedLevel = speedLevel;
                    if (speedIncrement >= scrollThreshold) {
                        speedLevel--;
                    } else if (speedIncrement <= -scrollThreshold) {
                        speedLevel++;
                    }
                    if (oldSpeedLevel != speedLevel) {
                        speedIncrement = 0;
                        speedLevel = Math.max(0, Math.min(speeds.length - 1, speedLevel));
                        scrollTimeout = 0;
                    }
                    ev.preventDefault();
                });
            }
        }
        function hookLoad(elem) {
            let init = false;
            const canvases = elem.querySelectorAll("canvas");
            elem.addEventListener("toggle", () => {
                if (!init) {
                    canvases.forEach(initializeElem);
                    init = true;
                }
            });
        }
        function hookToggle(elem) {
            const details = Array.from(document.querySelectorAll("details." + elem.dataset.target));
            elem.addEventListener("click", () => {
                if (details.some(x => x.open)) {
                    details.forEach(x => x.open = false);
                } else {
                    details.forEach(x => x.open = true);
                }
            });
        }
        const params = new URLSearchParams(document.location.search);
        function hookSpoiler(elem) {
            if (params.get("nospoiler") !== null) {
                elem.classList.add("unspoilered");
            } else {
                const thunk = ev => {
                    if (!elem.classList.contains("unspoilered")) {
                        ev.preventDefault();
                        ev.stopImmediatePropagation();
                        elem.classList.add("unspoilered");
                    }
                    elem.removeEventListener("click", thunk);
                };
                elem.addEventListener("click", thunk);

                if (elem instanceof HTMLAnchorElement) {
                    const href = elem.getAttribute("href");
                    if (href.startsWith("#")) {
                        elem.addEventListener("click", () => document.getElementById(href.substring(1)).querySelector(".spoilered").classList.add("unspoilered"));
                    }
                }
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('details.spell-collapsible').forEach(hookLoad);
            document.querySelectorAll('a.toggle-link').forEach(hookToggle);
            document.querySelectorAll('.spoilered').forEach(hookSpoiler);
            function tick(prevTime, time) {
                const dt = time - prevTime;
                for (const q of rfaQueue) {
                    q(dt);
                }
                requestAnimationFrame(t => tick(time, t));
            }
            requestAnimationFrame(t => tick(t, t));
        });

    </script>

</head>
<body>
<div class="container" style="margin-top: 3em;">
    <blockquote>
        <h1>This is the online version of the Hexbound documentation.</h1>
        <p>Embedded images and patterns are included, but not crafting recipes or items. There's an in-game book for
            those.</p>
        <p>Additionally, this is built from the latest code on GitHub. It may describe <b>newer</b> features that you
            may not necessarily have, even on the latest CurseForge version!</p>
        <p><b>Entries which are blurred are spoilers</b>. Click to reveal them, but be aware that they may spoil endgame
            progression. Alternatively, click <a href="?nospoiler">here</a> to get a version with all spoilers showing.
        </p>
    </blockquote>
</div>
<div class='container'><header class='jumbotron'><h1 class='book-title'>Hex Notebook</h1><p>I seem to have discovered a new method of magical arts, in which one draws patterns strange and wild onto a hexagonal grid. It fascinates me. I've decided to start a journal of my thoughts and findings.</p><p><a href='https://discord.gg/4xxHGYteWk'>Discord Server Link</a></p></header><nav><h2 id='table-of-contents' class='page-header'>Table of Contents<a href='javascript:void(0)' class='toggle-link small' data-target='toc-category'>(toggle all)</a><a href='#table-of-contents' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><details class='toc-category'><summary><a href='#basics' class=''>Getting Started</a></summary><ul><li><a href='#basics/hexbound_exists' class=''>Hexbinding</a></li></ul></details><details class='toc-category'><summary><a href='#casting' class=''>Hex Casting</a></summary><ul><li><a href='#casting/item_iotas' class=''>Item Iotas</a></li><li><a href='#casting/hexbound_mishaps' class=''>Hexbinding Mishaps</a></li><li><a href='#casting/figments' class=''>Figments</a></li></ul></details><details class='toc-category'><summary><a href='#greatwork' class='spoilered'>The Great Work</a></summary><ul><li><a href='#greatwork/impetus_figment' class='spoilered'>Impetus Figments</a></li></ul></details><details class='toc-category'><summary><a href='#interop' class=''>Cross-Mod Compatibility</a></summary><ul><li><a href='#interop/hexal_interop' class=''>Hexal-Hexbound</a></li></ul></details><details class='toc-category'><summary><a href='#patterns' class=''>Patterns</a></summary><ul><li><a href='#patterns/item_patterns' class=''>Item Patterns</a></li><li><a href='#patterns/pattern_editing' class=''>Pattern Editing</a></li></ul></details><details class='toc-category'><summary><a href='#patterns/spells' class=''>Spells</a></summary><ul><li><a href='#patterns/spells/colorizer_storage' class=''>Memorizing Pigments</a></li></ul></details><details class='toc-category'><summary><a href='#patterns/great_spells' class=''>Great Spells</a></summary><ul><li><a href='#patterns/great_spells/impetus_fake_player' class=''>Bind Figment</a></li></ul></details></nav><main class='book-body'><section id='basics'><h2 class='category-title page-header'>Getting Started<a href='#basics' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>The practitioners of this art would cast their so-called <span style='color: #b38ef3'>Hexes</span> by drawing strange patterns in the air with a <a href='#items/staff'><span style='color: #b0b'>staff</span></a>-- or craft <a href='#items/hexcasting'><span style='color: #b0b'>powerful magical items</span></a> to do the casting for them. How might I do the same?</p><div id='basics/hexbound_exists'><h3 class='entry-title page-header'>Hexbinding<a href='#basics/hexbound_exists' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>I have found evidence of a different branch of <span style='color: #b38ef3'>Hexcasting</span>. Known as <span style='color: #b38ef3'>Hexbinding</span>, this particular school uses media to create and control automata known as Constructs, manipulate items, and more. As always, I will document my findings in this journal.</p><br /></div></section><section id='casting'><h2 class='category-title page-header'>Hex Casting<a href='#casting' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>I've started to understand how the old masters cast their <span style='color: #b38ef3'>Hexes</span>! It's a bit complicated, but I'm sure I can figure it out. Let's see...</p><div id='casting/item_iotas'><h3 class='entry-title page-header'>Item Iotas<a href='#casting/item_iotas' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>I have discovered two additional types of iotas I can manipulate.</p><p>Item Iotas describe a singular item stripped of its properties, such as damage or enchantments.</p><p>Item Stack Iotas describe a stack of items as they might appear in my inventory, amount, custom names, enchantments, and all.</p><br /><p>It would also seem Item Stack iotas referring to Foci containing other Item Stack iotas are somewhat faulty. A limit to the depth of my thought perhaps.</p><br /></div><div id='casting/hexbound_mishaps'><h3 class='entry-title page-header'>Hexbinding Mishaps<a href='#casting/hexbound_mishaps' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>New schools of <span style='color: #b38ef3'>Hexcasting</span> bring new and exciting ways of utterly failing a <span style='color: #b38ef3'>Hex</span>. Here are some I have discovered.</p><br /><h4>Not Drawn By Construct</h4><p>The pattern drawn cannot be executed by anything except a <a href='#hexbound:patterns/constructs/constructs_intro'>Construct</a>. Causes purple sparks and slows me for a few seconds.</p><br /><h4>Construct Incapable</h4><p>The pattern drawn (usually a command) requires the Construct do something it cannot, such as attacking for a utility Construct. Causes yellow sparks.</p><br /><h4>Construct Is Forbidden</h4><p>I attempted to give orders to a Construct that will not accept any from me. Causes brown sparks and pushes me away from the Construct.</p><br /><h4>No Pigment Present</h4><p>I have not internalized a Pigment yet. Causes white sparks.</p><br /><h4>Too Many Pigments</h4><p>I have already memorized too many Pigments and cannot add another. Causes red sparks.</p><br /><h4>No Pigment For Key</h4><p>I have not <a href='#hexbound:patterns/spells/colorizer_storage'>memorized a Pigment</a> for the pattern I entered. Causes white sparks and causes me to lose my current Pigment.</p><br /></div><div id='casting/figments'><h3 class='entry-title page-header'>Figments<a href='#casting/figments' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>All my study shows that the act of casting a <span style='color: #b38ef3'>Hex</span> inevitably requires a living Caster exist <i>somewhere</i>. Perhaps an obvious and pointless detail: I am the one casting the <span style='color: #b38ef3'>Hex</span>, so the requirement is met, but should I discover <a href='#hexcasting:greatwork/spellcircle'>some means of independent casting</a> (or even rig a dispenser to flail a trinket around), it would lose the link and cease to function the moment I cross the portal to the Nether or elsewhere.</p><br /><p>However, I believe a specially designed web of <span style='color: #74b3f2'>media</span> could ''trick'' the <span style='color: #b38ef3'>Hex</span> into latching onto it long enough to resolve. These Figments as I've begun calling them, would either be severely limited in their abilities, as Constructs are, or would require something much more intricate to hold their hand through the <span style='color: #b38ef3'>Hex</span>, so to speak.<br />Moreover, Figments are not entirely self-aware: Mind's Reflection simply returns <a href='#hexcasting:casting/influences'><span style='color: #8d6acc'>Null</span></a>, while <a href='#hexcasting:patterns/spells/sentinels'>Sentinels</a> and <span style='color: #8d6acc'><a href='#hexcasting:items/pigments'>Pigments</a></span> are unreliable.</p><br /></div></section><section id='greatwork'><div class='spoilered'><h2 class='category-title page-header'>The Great Work<a href='#greatwork' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>I have seen... so much. I have... experienced... annihilation and deconstruction and reconstruction. I have seen the atoms of the world screaming as they were inverted and subverted and demoted to energy. I have seen I have seen I have s<span class='obfuscated'>get stick bugged lmao</span></p></div><div id='greatwork/impetus_figment'><div class='spoilered'><h3 class='entry-title page-header'>Impetus Figments<a href='#greatwork/impetus_figment' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>Now that I possess the means to contain a mind, I have revisited my notes on <a href='#hexbound:patterns/great_spells/impetus_fake_player'>Bind Figment</a> and confirmed that a <a href='#hexcasting:greatwork/impetuses'>Cleric Impetus</a> would be the perfect vessel for it. The Impetus must be bound to a <span style='color: #b38ef3'>Hexcaster</span> as <i>enlightened</i> as I am; no other mind would allow a piece of itself to be unraveled like this.</p><p>Not yet. THEY WILL. In time.</p><br /><p>Furthermore, if the Impetus can connect to its bound caster, that connection will take priority over the Figment.</p><p>A thought with no mind bound to a lattice every thought wrapped and screaming it is not itself it always made sense it will never make sense <span class='obfuscated'>hello penguin</span></p><p>Ten <span style='color: #74b3f2'>Charged Amethyst</span> for the spell.</p><br /></div></div></section><section id='interop'><h2 class='category-title page-header'>Cross-Mod Compatibility<a href='#interop' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>It appears I have installed some mods Hexcasting interoperates with! I've detailed them here.</p><div id='interop/hexal_interop'><h3 class='entry-title page-header'>Hexal-Hexbound<a href='#interop/hexal_interop' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>It appears some of the <span style='color: #b38ef3'>Hexcasting</span> disciplines I've encountered can operate together.</p><p> First, I've discovered that <a href='#hexbound:casting/item_iotas'>Item Iotas</a>, as created by the likes of <a href='#hexbound:patterns/item_patterns@hexbound:get_main_hand'>Duelist's Purification</a>, and Item Type Iotas, as created by <a href='#hexbound:hexal:patterns/types@hexal:type/entity'>Physician's Purification</a>, are near-identical! Comparisons between them or their types should therefore work as expected.</p><br /><p>The second and, perhaps, even more important discovery is the ability of <a href='#hexbound:patterns/constructs/constructs_intro'>Constructs</a> to maintain <a href='#hexbound:hexal:patterns/spells/links'>Links</a>. This will allow me to send iotas between Wisps and Constructs, or even Constructs and myself! The possibilities are well and truly endless.</p><br /></div></section><section id='patterns'><h2 class='category-title page-header'>Patterns<a href='#patterns' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>A list of all the patterns I've discovered, as well as what they do.</p><div id='patterns/item_patterns'><h3 class='entry-title page-header'>Item Patterns<a href='#patterns/item_patterns' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/item_patterns@hexbound:get_stack_prop/item'><h4 class='pattern-title'>Logistician's Purification (item stack → item)<a href='#patterns/item_patterns@hexbound:get_stack_prop/item' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='dedqaa' data-start='west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: dedqaa</canvas></details><p>Transforms the <a href='#hexbound:casting/item_iotas'>Item Stack</a> at the top of the stack into its Item.</p></div><br /><div id='patterns/item_patterns@hexbound:get_stack_prop/size'><h4 class='pattern-title'>Treasurer's Purification (item stack → item)<a href='#patterns/item_patterns@hexbound:get_stack_prop/size' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='dedqaq' data-start='west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: dedqaq</canvas></details><p>Transforms the Item Stack at the top of the stack into its size.</p></div><br /><div id='patterns/item_patterns@hexbound:get_main_hand'><h4 class='pattern-title'>Duelist's Purification (entity → item stack)<a href='#patterns/item_patterns@hexbound:get_main_hand' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='adeq' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: adeq</canvas></details><p>Transforms the entity at the top of the stack into the Item Stack in its main hand. Also works on Item Frames and dropped items.</p></div><br /><div id='patterns/item_patterns@hexbound:get_off_hand'><h4 class='pattern-title'>Shieldbearer's Purification (entity → item stack)<a href='#patterns/item_patterns@hexbound:get_off_hand' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qeda' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qeda</canvas></details><p>Transforms the entity at the top of the stack into the Item Stack in its off hand.</p></div><br /><div id='patterns/item_patterns@hexbound:get_inventory/stacks'><h4 class='pattern-title'>Hoarder's Distillation (vector, vector → list)<a href='#patterns/item_patterns@hexbound:get_inventory/stacks' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='aqwed' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: aqwed</canvas></details><p>Removes two vectors from the stack representing position and side. Returns a list of Item Stacks in the block at the given position accessible from the given side (or all if second vector is zero).</p></div><br /><div id='patterns/item_patterns@hexbound:get_inventory/items'><h4 class='pattern-title'>Collector's Distillation (vector, vector → list)<a href='#patterns/item_patterns@hexbound:get_inventory/items' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='dewqa' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: dewqa</canvas></details><p>Removes two vectors from the stack representing position and side. Returns a list of Items in the block at the given position accessible from the given side (or all if second vector is zero).</p></div><br /></div><div id='patterns/pattern_editing'><h3 class='entry-title page-header'>Pattern Editing<a href='#patterns/pattern_editing' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>Some patterns I found seem to allow editing other patterns in multiple ways, even producing patterns that would ordinarily be impossible to draw.</p><p>Exciting as that may sound, anything possible I could just draw myself, and any impossible pattern is very unlikely to produce valuable results.<br />Some look pretty good on a <a href='#hexcasting:items/scroll'>Scroll</a> though, so not entirely pointless!</p><br /><div id='patterns/pattern_editing@hexbound:rotate_pattern'><h4 class='pattern-title'>Revolving Distillation (pattern, num →)<a href='#patterns/pattern_editing@hexbound:rotate_pattern' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='deeee' data-start='west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: deeee</canvas></details><p>Removes a pattern and an integer from the stack and rotates the pattern the number of times given by the integer. Positive numbers rotate clockwise, while negative rotate counter-clockwise.</p></div><br /><div id='patterns/pattern_editing@hexbound:merge_patterns'><h4 class='pattern-title'>Painter's Distillation (pattern, pattern →)<a href='#patterns/pattern_editing@hexbound:merge_patterns' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='aqqqqa' data-start='north_west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: aqqqqa</canvas></details><p>Removes two patterns and merges them, as if first stroke of the second was drawn from the last point of the first. It appears excessively large patterns will simply end after a certain point instead.</p></div><br /></div></section><section id='patterns/spells'><h2 class='category-title page-header'>Spells<a href='#patterns/spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>Patterns and actions that perform a magical effect on the world.</p><div id='patterns/spells/colorizer_storage'><h3 class='entry-title page-header'>Memorizing Pigments<a href='#patterns/spells/colorizer_storage' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>The patterns in this chapter allow me to memorize <span style='color: #8d6acc'><a href='#hexcasting:items/pigments'>Pigments</a></span> I have already Internalized.</p><p>Using these patterns associates a Pigment with a pattern of my choosing in my mind, allowing me to revert to it whenever I please. I will never run out of eggs again!</p><br /><div id='patterns/spells/colorizer_storage@hexbound:colorizer/save'><h4 class='pattern-title'>Memorize Pigment (pattern →)<a href='#patterns/spells/colorizer_storage@hexbound:colorizer/save' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='wqwawqqawddwqwede' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: wqwawqqawddwqwede</canvas></details><p>Removes a pattern from the stack and associates my current Pigment with that pattern.</p></div><br /><div id='patterns/spells/colorizer_storage@hexbound:colorizer/load'><h4 class='pattern-title'>Recall Pigment (pattern →)<a href='#patterns/spells/colorizer_storage@hexbound:colorizer/load' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='wqwawqqawddwqeqaq' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: wqwawqqawddwqeqaq</canvas></details><p>Removes a pattern from the stack and sets my current Pigment to the one I have associated with that pattern</p></div><br /><div id='patterns/spells/colorizer_storage@hexbound:colorizer/delete'><h4 class='pattern-title'>Forget Pigment (pattern →)<a href='#patterns/spells/colorizer_storage@hexbound:colorizer/delete' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='wqwawqqawddwqwdd' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: wqwawqqawddwqwdd</canvas></details><p>Removes a pattern from the stack, and forgets the Pigment I have associated with that pattern.</p></div><br /></div></section><section id='patterns/great_spells'><h2 class='category-title page-header'>Great Spells<a href='#patterns/great_spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>The spells catalogued here are purported to be of legendary difficulty and power. They seem to have been recorded only sparsely (for good reason, the texts claim). It's probably just the hogwash of extinct traditionalists, though-- a pattern's a pattern. What could possibly go wrong?</p><div id='patterns/great_spells/impetus_fake_player'><h3 class='entry-title page-header'>Bind Figment<a href='#patterns/great_spells/impetus_fake_player' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/great_spells/impetus_fake_player@hexbound:set_fake_impetus_player'><h4 class='pattern-title'>Bind Figment (vector →)<a href='#patterns/great_spells/impetus_fake_player@hexbound:set_fake_impetus_player' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qaqdaqwqaeedewd' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qaqdaqwqaeedewd</canvas></details><p>Removes a vector from the stack and binds a <a href='#hexbound:casting/figments'>Figment</a> to the block at the position represented by the vector.<br />I can't tell what the <a href='#hexbound:greatwork/impetus_figment'>target</a> is supposed to be though.</p></div><br /></div></section></main></div>
</body>
</html>
